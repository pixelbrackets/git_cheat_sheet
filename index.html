<!DOCTYPE HTML>
	<html lang="en-US">
	<head>
		<meta charset="UTF-8">
		<title></title>
		<link href="screen.css" rel="stylesheet" type="text/css">
	</head>
	<body>
		<div id="wrapper"><h1>Git Cheat Sheet</h1>
<ul>
<li>Legend: <code>&lt;&gt;</code> required, <code>[]</code> optional</li>
</ul>
<h2>Common Terminology</h2>
<ul>
<li>commit ≙ object with annotated changes in relation other commits</li>
<li>branch ≙ collection of commits</li>
<li>stage ≙ files earmarked for the next commit</li>
<li>HEAD ≙ reference to the top commit in the current branch</li>
<li>remote = bookmark for a repository origin (a repository may have several remotes)</li>
</ul>
<h2>Create &amp; Clone</h2>
<ul>
<li>
<p>Clone an existing repository</p>
<pre><code>git clone &lt;URL&gt; [folder]
</code></pre>
<p><em>Default protocoll is SSH, eg. »<a href="mailto:git@example.com">git@example.com</a>:repo.git«. HTTPS would be »<a href="https://example.com/repo.git%C2%AB">https://example.com/repo.git«</a>, another local repo »/home/user/repo.git«</em></p>
<p><em>Creates a subfolder with the repo, if the folder name is not given, then the repo name is used (»foo.git« = »./foo« subfolder)</em></p>
</li>
<li>
<p>Create a new local repository</p>
<pre><code>git init &lt;folder&gt;
</code></pre>
<p><em>If a folder name is given, a subfolder is created, otherwise the current folder is used</em></p>
</li>
<li>
<p>Send existing local repository to remote</p>
<pre><code>git remote add origin &lt;URL&gt; &amp;&amp; git push &lt;remote&gt; &lt;branch&gt;
</code></pre>
</li>
<li>
<p>Special: Create an empty repository on a remote server</p>
<p><em>Connect with the remote server first</em></p>
<pre><code>mkdir &lt;repo&gt;.git &amp;&amp; cd &lt;repo&gt;.git &amp;&amp; git init --bare
</code></pre>
<p><em>The remote repository has to be »bare« (does not contain a working filetree, but a special .git subdirectory only) in order to accept a push</em></p>
</li>
</ul>
<h2>Show changes</h2>
<ul>
<li>
<p>Show working status - show current branch name and changed or new files</p>
<pre><code>git status
</code></pre>
<p><em>Hint: Set a short alias for often used commands, like <code>git st</code> for <code>git status</code> → see »Configuration«</em></p>
</li>
<li>
<p>Difference between HEAD and files not yet staged</p>
<pre><code>git diff
</code></pre>
<p><em>Note: This ignores new files = files which were not added to the repository yet and therefore arent »tracked«</em></p>
</li>
<li>
<p>Difference between HEAD and staged files</p>
<pre><code>git diff --cached
</code></pre>
</li>
<li>
<p>Difference between HEAD and all files (staged and not staged)</p>
<pre><code>git diff HEAD
</code></pre>
</li>
<li>
<p>Difference between branches, two commits, etc</p>
<pre><code>git diff &lt;foo&gt; &lt;bar&gt;
</code></pre>
<p><em>»+« line does exist in »bar« but not in »foo«, »-« reverse</em></p>
</li>
<li>
<p>Difference to another branch and show names of changed files only</p>
<pre><code>git diff &lt;branch&gt; --name-status
</code></pre>
</li>
<li>
<p>Show all commits of current branch which are not merged into another branch</p>
<pre><code>git log &lt;reference&gt;.. --oneline
</code></pre>
<p><em>The reference may be a branch or a tag, note the two dots at the end</em></p>
</li>
<li>
<p>Show branches in which one commit exists</p>
<pre><code>git branch --contains &lt;commit ID&gt;
</code></pre>
</li>
</ul>
<h2>Show history</h2>
<ul>
<li>
<p>Show all commits of current branch</p>
<pre><code>git log
</code></pre>
</li>
<li>
<p>Show all commits of current branch and names of each changed file</p>
<pre><code>git whatchanged
</code></pre>
</li>
<li>
<p>Show commits and each difference for a specific file</p>
<pre><code>git log -p &lt;file&gt;
</code></pre>
</li>
<li>
<p>Examination: Show who changed what and when in a file</p>
<pre><code>git blame &lt;file&gt;
</code></pre>
<p><em>Left side shows the last commit ID for the content on the right side</em></p>
</li>
<li>
<p>Show a single commit and its differences</p>
<pre><code>git show &lt;commit ID&gt;
</code></pre>
</li>
<li>
<p>Show all commits with a certain word in the commit message</p>
<pre><code>git log --grep=&lt;searchword&gt;
</code></pre>
</li>
</ul>
<h2>Commit</h2>
<ul>
<li>
<p>Stage all (even untracked) files</p>
<pre><code>git add -A
</code></pre>
</li>
<li>
<p>Stage a tracked and modified file</p>
<pre><code>git add &lt;file&gt;
</code></pre>
</li>
<li>
<p>Add hand-picked changes in a file to the next commit (≙ partial commit)</p>
<pre><code>git add -p &lt;file&gt;
</code></pre>
<p><code>y</code> <em>Yes, add this part to the next commit</em><br>
<code>n</code> <em>No, skip this part</em><br>
<code>d</code> <em>Don’t add this and all remaining parts of the file</em><br>
<code>s</code> <em>Try to split the current part into smaller ones</em><br>
<code>e</code> <em>Manually edit the part</em></p>
</li>
<li>
<p>Stage all changes in tracked files and start a commit</p>
<pre><code>git commit -a
</code></pre>
</li>
<li>
<p>Commit all previously staged changes</p>
<pre><code>git commit
  git commit -m "&lt;message&gt;"
</code></pre>
</li>
</ul>
<h2>Branches</h2>
<ul>
<li>
<p>List local branches</p>
<pre><code>git branch
</code></pre>
<p><em><code>*</code> marks the current branch</em></p>
</li>
<li>
<p>List remote branches</p>
<pre><code>git branch -r
</code></pre>
<p><em>use <code>-a</code> to show local and remote branches at once</em></p>
</li>
<li>
<p>Switch to a different branch</p>
<pre><code>git checkout &lt;branch&gt;
  git checkout -t &lt;remote&gt;/&lt;remote-branch&gt;
</code></pre>
<p><em><code>-t</code> checkout a new branch based on remote branch and save their connection</em></p>
</li>
<li>
<p>Create a new branch based on HEAD</p>
<pre><code>git branch &lt;new-branch&gt;
</code></pre>
<p><em>use <code>git checkout -b &lt;branch&gt;</code> to create a branch and switch right into it</em></p>
</li>
<li>
<p>Create a new branch based on a remote branch</p>
<pre><code>git branch --track &lt;new-branch&gt; &lt;remote&gt;/&lt;remote-branch&gt;
</code></pre>
<p><em>use <code>--no-track</code> to create a new branch based on a remote branch, but don't save a connection between both</em></p>
</li>
<li>
<p>Connect a remote branch with a local branch</p>
<pre><code>git branch --track &lt;local-branch&gt; &lt;remote&gt;/&lt;remote-branch&gt;
</code></pre>
</li>
<li>
<p>Show merged branches</p>
<pre><code>git branch -a --merged
</code></pre>
<p><em><code>--no-merged</code> will show branches not merged yet</em></p>
</li>
<li>
<p>Delete a local branch</p>
<pre><code>git branch -d &lt;branch&gt;
</code></pre>
<p><em><code>-d</code> will only delete the branch if it is merged with its remote branch (if set), <code>-D</code> will force the deletion</em></p>
</li>
<li>
<p>Delete a remote branch</p>
<pre><code>git push &lt;remote&gt; :&lt;remote-branch&gt;
</code></pre>
</li>
</ul>
<h2>Tags</h2>
<p>Use tags to save a specific version (the commit relations up to this point) of a project. Merging older commits into the branch afterwards hence wont affect the tag.</p>
<ul>
<li>
<p>Show all tags</p>
<pre><code>git tag -n
</code></pre>
<p><em><code>-l</code> will show tag names only, <code>-n&lt;num&gt;</code> will add a number of lines from the annotation (default is one)</em></p>
</li>
<li>
<p>Mark the current commit with a tag</p>
<pre><code>git tag &lt;tag-name&gt; -m "&lt;annotation&gt;"
</code></pre>
<p><em>Hint: Use semantic version numbers as tags</em></p>
</li>
</ul>
<h2>Update</h2>
<ul>
<li>
<p>Download all changes from , but don't merge to HEAD yet</p>
<pre><code>git fetch &lt;remote&gt;
</code></pre>
<p><em>A manual merge is required now</em></p>
</li>
<li>
<p>Download changes and directly merge to HEAD</p>
<pre><code>git pull [&lt;remote&gt; &lt;branch&gt;]
</code></pre>
<p><em>If the connection between remote &amp; local branch is saved, then <code>git pull</code> is sufficient</em></p>
</li>
<li>
<p>List all currently configured remote repositories</p>
<pre><code>git remote -v
</code></pre>
</li>
<li>
<p>Show information about a remote, eg. which branches exist in this remote</p>
<pre><code>git remote show &lt;remote&gt;
</code></pre>
</li>
<li>
<p>Remove stale remote branch trackings (outdated connections)</p>
<pre><code>git remote prune &lt;remote&gt;
</code></pre>
<p><em>Remove connections to branches deleted on the remote by now - does not delete the local branch</em></p>
</li>
<li>
<p>Add a new remote repository</p>
<pre><code>git remote add &lt;remote&gt; &lt;url&gt;
</code></pre>
</li>
</ul>
<h2>Publish</h2>
<ul>
<li>
<p>Push local branch or tag to remote</p>
<pre><code>git push [&lt;remote&gt; &lt;branch|tag&gt;]
</code></pre>
<p><em>use »-u« to push the branch and automatically save the connection between local &amp; remote</em></p>
</li>
<li>
<p>Push all local branches to remote</p>
<pre><code>git push --all &lt;remote&gt;
</code></pre>
</li>
<li>
<p>Push all tags to remote</p>
<pre><code>git push --tags &lt;remote&gt;
</code></pre>
</li>
</ul>
<h2>Merge</h2>
<ul>
<li>
<p>Merge a branch into your current HEAD</p>
<pre><code>git merge &lt;branch&gt;
</code></pre>
</li>
<li>
<p>Manually solve conflicts and mark file as resolved</p>
<pre><code>git add &lt;resolved-file&gt; &amp;&amp; git commit -m 'Manual Merge'
</code></pre>
</li>
<li>
<p>Use a tool to solve merge conflicts</p>
<pre><code>git mergetool
</code></pre>
<p><em>will use tool set in »merge.tool«, use »-t « to start a custom tool</em></p>
</li>
<li>
<p>Use a merge strategy</p>
<pre><code>git merge -s recursive -X &lt;ours|theirs|patience&gt;
</code></pre>
<p><em>»recursive« is the default merge strategy when pulling or merging one branch, so this param may be redundant</em><br>
<em>»ours« merge commits but try to ignore all conflicting changes from the other branch</em><br>
<em>»theirs« merge commits but try to ignore conflicts introduced by the own branch</em><br>
<em>»patience« will cause GIT run rather time-consuming intelligent merge routines to avoid merge conflicts and errors in the first place</em></p>
</li>
<li>
<p>Cancel merge</p>
<pre><code>git merge --abort
</code></pre>
</li>
</ul>
<h2>Rebase</h2>
<p>Use rebase with care! It will rewrite the history and therefore requires additional efforts when working with a team! Dont rebase unless every project member knows about the required workflow!</p>
<ul>
<li>
<p>Rewrite commits from HEAD until given commit</p>
<pre><code>git rebase -i &lt;commit ID&gt;
</code></pre>
<p><em>Opens an editable rebase command list - reorder the commands to change commit order, remove a line to delete the commit, change the preceded keyword to change the command</em></p>
<p><code>p|pick</code> <em>keep commit</em><br>
<code>r|reword</code> <em>use commit, but edit the commit message</em><br>
<code>e|edit</code> <em>use commit, but halt the rebase sequence to change the commit (use <code>git commit --amend -a</code>)</em><br>
<code>s|squash</code> <em>use commit, but meld into previous commit</em></p>
</li>
<li>
<p>Rebase your current HEAD onto </p>
<pre><code>git rebase &lt;branch&gt;
</code></pre>
<p><em>Merges all commits of given branch and applies new commits of the local branch on top (creates new commit IDs for these)</em></p>
</li>
<li>
<p>Abort a rebase</p>
<pre><code>git rebase --abort
</code></pre>
</li>
<li>
<p>Continue a rebase after resolving conflicts</p>
<pre><code>git rebase --continue
</code></pre>
</li>
</ul>
<h2>Stash</h2>
<p>Use stash to save all current changes to a clipboard and retrieve them later.</p>
<ul>
<li>
<p>Stash all changes away</p>
<pre><code>git stash save [comment]
</code></pre>
</li>
<li>
<p>Show all available stashes</p>
<pre><code>git stash list
</code></pre>
<p><em>»stash@{0}« is the rather unreadable name of the stash state, where 0 is the latest</em></p>
</li>
<li>
<p>Retrieve a state form the stash list</p>
<pre><code>git stash apply &lt;stash-name&gt;
</code></pre>
<p><em>default is »stash@{0}«, use <code>git stash pop &lt;stash-name&gt;</code> to apply changes and remove the state from stash list</em></p>
</li>
<li>
<p>Remove a state from the stash list</p>
<pre><code>git stash drop &lt;stash-name&gt;
</code></pre>
</li>
<li>
<p>Remove all the stashed states</p>
<pre><code>git stash clear
</code></pre>
</li>
</ul>
<h2>Revert</h2>
<p>Git is merciful and lets you undo allmost all changes with ease.</p>
<ul>
<li>
<p>Clear stage (≙ unadd files)</p>
<pre><code>git reset HEAD --
</code></pre>
</li>
<li>
<p>Discard all changes</p>
<pre><code>git checkout -- [file]
</code></pre>
</li>
<li>
<p>Change the last commit</p>
<pre><code>git commit --amend -a
</code></pre>
<p><em>Replaces the last commit (new ID), so it should only be used if the modified branch was not pushed yet</em></p>
</li>
<li>
<p>Special: Change author of the last commit</p>
<pre><code>git commit --amend --author "John Doe &lt;doe@example.com&gt;"
</code></pre>
</li>
<li>
<p>Remove the last commit but keep all files and changes</p>
<pre><code>git reset HEAD~1
</code></pre>
<p><em>Removes the last commit from the local history</em></p>
</li>
<li>
<p>Revert a commit (≙ apply inversion)</p>
<pre><code>git revert &lt;commit-id&gt;
</code></pre>
<p><em>Inverts changes of the given commit, applies them to the working directory and starts a new commit</em></p>
</li>
<li>
<p>Undo a local merge</p>
<pre><code>git reset --hard &lt;merge commit ID&gt;
</code></pre>
<p><em>Use only if the branch wasn't pushed yet, otherwise rebase or revert</em></p>
</li>
<li>
<p>Remove a file</p>
<pre><code>git rm --cached
</code></pre>
<p><em>Removes the file from the git repository index but keeps it on the file system</em></p>
</li>
</ul>
<h2>Configuration</h2>
<ul>
<li>
<p>Get configuration option</p>
<pre><code>git config &lt;section&gt;.&lt;key&gt;
</code></pre>
</li>
<li>
<p>Set configuration option</p>
<pre><code>git config --local &lt;section&gt;.&lt;key&gt; &lt;value&gt;
</code></pre>
<p><em>»local« will write to ».git/config« in current repository, »global« to »~/.gitconfig» and »system« to your systems »/etc/gitconfig«</em></p>
</li>
<li>
<p>Set username and e-mail</p>
<pre><code>git config --local user.name "&lt;username&gt;" &amp;&amp; git config --local user.email &lt;e-mail&gt;
</code></pre>
</li>
<li>
<p>Ignore mode changes (chmod)</p>
<pre><code>git config --local core.filemode false
</code></pre>
</li>
<li>
<p>Set alias »st« for »status«</p>
<pre><code>git config --global alias.st status
</code></pre>
</li>
</ul>
<h2>Commit Message Format</h2>
<pre><code>[BUGFIX] Short summary

Optional explanatory text. Separated by new line. Wrapped to 74 chars. Written in imperative present tense ("Fix bug", not "Fixed bug").

Help others to understand what you did (Motivation for the change? Difference to previous version?), but keep it simple.

Mandatory title prefix: [BUGFIX], [FEATURE] (also small additions) or [TASK] (none of the above, e.g. code cleanup). Additionall flags: [!!] (breaking change), [DB] (alter database definition), [CONF] (configuration change), [SECURITY] (fix a security issue).

Bug tracker refs added at bottom (see http://is.gd/commit_refs).

Resolve #42
Ref #4 #8 #15 #16
</code></pre>
<p><em>shortened, detailed example at <a href="http://is.gd/commitformat">http://is.gd/commitformat</a></em></p>
<h2>Best practices</h2>
<ul>
<li>Commit related changes
<ul>
<li>Each commit should adress one logical unit. Two different bugs should result into two commits.</li>
</ul>
</li>
<li>Commit early &amp; often
<ul>
<li>Keep your commits small and comprehensible, split large features into logical chunks.</li>
</ul>
</li>
<li>Test code before committing
<ul>
<li>Make sure the code works, don't guess. Or let tools test your commit automatically. Revert faulty commits if necessary.</li>
</ul>
</li>
<li>Don't commit half-done work
<ul>
<li>Commit only complete, logical changes, not half-done chunks. »Stash« changes if applicable.</li>
</ul>
</li>
<li>Don't commit hot files
<ul>
<li>Don't commit configuration files (commit a config template instead), personal data, temporary files (GIT is no backup system) or things that can be regenerated form other commited things.</li>
</ul>
</li>
<li>Write good commit messages
<ul>
<li>Help others to understand what you did (Motivation for the change? Whats the difference to the previous version?)</li>
<li>Useless commit messages may be forwarded to whatthecommit.com</li>
</ul>
</li>
<li>Write in imperative present tense («change», not «changed» or «changes»)
<ul>
<li>A commit is a set of instructions for how to go from a previous state to a new state, so you should describe was the commit does and not what it did to your repository.</li>
</ul>
</li>
<li>Don't panic
<ul>
<li>GIT lets you undo, fix or remove a bunch of actions</li>
</ul>
</li>
<li>Don't change published history
<ul>
<li>GIT allows you to rewrite public history, but it is problematic for everyone and thus it is just not best practice to do so.</li>
</ul>
</li>
<li>Use branches
<ul>
<li>Branching is cheap. Use separate branches for each bugfix, feature &amp; idea. Make branching a part of your local workflow.</li>
</ul>
</li>
<li>Merge regularly
<ul>
<li>Don't merge a huge feature into the master, instead merge the master regularly with your branch.</li>
</ul>
</li>
<li>Use conventions
<ul>
<li>As with every development process: use conventions. For naming of branches and tags, how to write commit messages, when to commit into what branch, etc.</li>
</ul>
</li>
</ul>
<h2>Sources</h2>
<ul>
<li><a href="https://github.com/yguo89/RTOS/wiki/Git-Cheat-Sheet">Git Cheat Sheet by Ying Guo</a></li>
<li><a href="http://www.git-tower.com/files/cheatsheet/Git_Cheat_Sheet_grey.pdf">Git Cheat Sheet by Git Tower</a></li>
<li><a href="http://gitready.com/">http://gitready.com/</a></li>
<li><a href="http://git-scm.com/documentation">http://git-scm.com/documentation</a></li>
<li><a href="http://wiki.typo3.org/CommitMessage_Format_(Git)">http://wiki.typo3.org/CommitMessage_Format_(Git)</a></li>
</ul>
<h2>About</h2>
<ul>
<li>Supervisor: Dan Untenzu <a href="https://twitter.com/pixelbrackets">@pixelbrackets</a></li>
<li>License: <a href="https://creativecommons.org/licenses/by-sa/3.0/de/">CC-BY-SA 3.0</a></li>
<li>Download &amp; Contribution: <a href="https://pixelbrackets.de/git-cheat-sheet">pixelbrackets.de/git-cheat-sheet</a></li>
</ul></div>
	</body>
	</html>